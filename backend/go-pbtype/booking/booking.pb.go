// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: booking/booking.proto

package booking

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	bookedroom "github.com/nekizz/final-project/backend/go-pbtype/bookedroom"
	hotel "github.com/nekizz/final-project/backend/go-pbtype/hotel"
	notification "github.com/nekizz/final-project/backend/go-pbtype/notification"
	payment "github.com/nekizz/final-project/backend/go-pbtype/payment"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Booking struct {
	Id                   int32                    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Note                 string                   `protobuf:"bytes,4,opt,name=note,proto3" json:"note,omitempty"`
	TotalPrice           float32                  `protobuf:"fixed32,5,opt,name=total_price,json=totalPrice,proto3" json:"total_price,omitempty"`
	Status               string                   `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	CustomerId           int32                    `protobuf:"varint,8,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Hotel                *hotel.Hotel             `protobuf:"bytes,7,opt,name=hotel,proto3" json:"hotel,omitempty"`
	Payment              *payment.PaymentV2       `protobuf:"bytes,9,opt,name=payment,proto3" json:"payment,omitempty"`
	StartDate            string                   `protobuf:"bytes,10,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	EndDate              string                   `protobuf:"bytes,11,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	Bookedroom           []*bookedroom.BookedRoom `protobuf:"bytes,12,rep,name=bookedroom,proto3" json:"bookedroom,omitempty"`
	CreatedAt            string                   `protobuf:"bytes,20,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt            string                   `protobuf:"bytes,21,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Booking) Reset()         { *m = Booking{} }
func (m *Booking) String() string { return proto.CompactTextString(m) }
func (*Booking) ProtoMessage()    {}
func (*Booking) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{0}
}
func (m *Booking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Booking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Booking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Booking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Booking.Merge(m, src)
}
func (m *Booking) XXX_Size() int {
	return m.Size()
}
func (m *Booking) XXX_DiscardUnknown() {
	xxx_messageInfo_Booking.DiscardUnknown(m)
}

var xxx_messageInfo_Booking proto.InternalMessageInfo

func (m *Booking) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Booking) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *Booking) GetTotalPrice() float32 {
	if m != nil {
		return m.TotalPrice
	}
	return 0
}

func (m *Booking) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Booking) GetCustomerId() int32 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *Booking) GetHotel() *hotel.Hotel {
	if m != nil {
		return m.Hotel
	}
	return nil
}

func (m *Booking) GetPayment() *payment.PaymentV2 {
	if m != nil {
		return m.Payment
	}
	return nil
}

func (m *Booking) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *Booking) GetEndDate() string {
	if m != nil {
		return m.EndDate
	}
	return ""
}

func (m *Booking) GetBookedroom() []*bookedroom.BookedRoom {
	if m != nil {
		return m.Bookedroom
	}
	return nil
}

func (m *Booking) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Booking) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func (*Booking) XXX_MessageName() string {
	return "booking.Booking"
}

type BookingV2 struct {
	Id                   int32                    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Note                 string                   `protobuf:"bytes,4,opt,name=note,proto3" json:"note,omitempty"`
	CustomerId           int32                    `protobuf:"varint,8,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Total                float32                  `protobuf:"fixed32,9,opt,name=total,proto3" json:"total,omitempty"`
	StartDate            string                   `protobuf:"bytes,10,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	EndDate              string                   `protobuf:"bytes,11,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	Bookedroom           []*bookedroom.BookedRoom `protobuf:"bytes,12,rep,name=bookedroom,proto3" json:"bookedroom,omitempty"`
	CreatedAt            string                   `protobuf:"bytes,20,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt            string                   `protobuf:"bytes,21,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *BookingV2) Reset()         { *m = BookingV2{} }
func (m *BookingV2) String() string { return proto.CompactTextString(m) }
func (*BookingV2) ProtoMessage()    {}
func (*BookingV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{1}
}
func (m *BookingV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BookingV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BookingV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BookingV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BookingV2.Merge(m, src)
}
func (m *BookingV2) XXX_Size() int {
	return m.Size()
}
func (m *BookingV2) XXX_DiscardUnknown() {
	xxx_messageInfo_BookingV2.DiscardUnknown(m)
}

var xxx_messageInfo_BookingV2 proto.InternalMessageInfo

func (m *BookingV2) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BookingV2) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *BookingV2) GetCustomerId() int32 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *BookingV2) GetTotal() float32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *BookingV2) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *BookingV2) GetEndDate() string {
	if m != nil {
		return m.EndDate
	}
	return ""
}

func (m *BookingV2) GetBookedroom() []*bookedroom.BookedRoom {
	if m != nil {
		return m.Bookedroom
	}
	return nil
}

func (m *BookingV2) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *BookingV2) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func (*BookingV2) XXX_MessageName() string {
	return "booking.BookingV2"
}

type OneBookingRequest struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OneBookingRequest) Reset()         { *m = OneBookingRequest{} }
func (m *OneBookingRequest) String() string { return proto.CompactTextString(m) }
func (*OneBookingRequest) ProtoMessage()    {}
func (*OneBookingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{2}
}
func (m *OneBookingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OneBookingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OneBookingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OneBookingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OneBookingRequest.Merge(m, src)
}
func (m *OneBookingRequest) XXX_Size() int {
	return m.Size()
}
func (m *OneBookingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OneBookingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OneBookingRequest proto.InternalMessageInfo

func (m *OneBookingRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (*OneBookingRequest) XXX_MessageName() string {
	return "booking.OneBookingRequest"
}

type ListCustomerBookingRequest struct {
	CustomerId           uint32   `protobuf:"varint,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Page                 uint32   `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	Limit                uint32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	CreatedAtMin         string   `protobuf:"bytes,5,opt,name=created_at_min,json=createdAtMin,proto3" json:"created_at_min,omitempty"`
	CreatedAtMax         string   `protobuf:"bytes,6,opt,name=created_at_max,json=createdAtMax,proto3" json:"created_at_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCustomerBookingRequest) Reset()         { *m = ListCustomerBookingRequest{} }
func (m *ListCustomerBookingRequest) String() string { return proto.CompactTextString(m) }
func (*ListCustomerBookingRequest) ProtoMessage()    {}
func (*ListCustomerBookingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{3}
}
func (m *ListCustomerBookingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCustomerBookingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCustomerBookingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCustomerBookingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCustomerBookingRequest.Merge(m, src)
}
func (m *ListCustomerBookingRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCustomerBookingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCustomerBookingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCustomerBookingRequest proto.InternalMessageInfo

func (m *ListCustomerBookingRequest) GetCustomerId() uint32 {
	if m != nil {
		return m.CustomerId
	}
	return 0
}

func (m *ListCustomerBookingRequest) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListCustomerBookingRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListCustomerBookingRequest) GetCreatedAtMin() string {
	if m != nil {
		return m.CreatedAtMin
	}
	return ""
}

func (m *ListCustomerBookingRequest) GetCreatedAtMax() string {
	if m != nil {
		return m.CreatedAtMax
	}
	return ""
}

func (*ListCustomerBookingRequest) XXX_MessageName() string {
	return "booking.ListCustomerBookingRequest"
}

type ListCustomerBookingResponse struct {
	Items                []*Booking `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	MaxPage              uint32     `protobuf:"varint,2,opt,name=max_page,json=maxPage,proto3" json:"max_page,omitempty"`
	TotalCount           uint32     `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	Page                 uint32     `protobuf:"varint,4,opt,name=page,proto3" json:"page,omitempty"`
	Limit                uint32     `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListCustomerBookingResponse) Reset()         { *m = ListCustomerBookingResponse{} }
func (m *ListCustomerBookingResponse) String() string { return proto.CompactTextString(m) }
func (*ListCustomerBookingResponse) ProtoMessage()    {}
func (*ListCustomerBookingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{4}
}
func (m *ListCustomerBookingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCustomerBookingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCustomerBookingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCustomerBookingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCustomerBookingResponse.Merge(m, src)
}
func (m *ListCustomerBookingResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListCustomerBookingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCustomerBookingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListCustomerBookingResponse proto.InternalMessageInfo

func (m *ListCustomerBookingResponse) GetItems() []*Booking {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListCustomerBookingResponse) GetMaxPage() uint32 {
	if m != nil {
		return m.MaxPage
	}
	return 0
}

func (m *ListCustomerBookingResponse) GetTotalCount() uint32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ListCustomerBookingResponse) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListCustomerBookingResponse) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (*ListCustomerBookingResponse) XXX_MessageName() string {
	return "booking.ListCustomerBookingResponse"
}

type ListHostBookingRequest struct {
	HostId               uint32   `protobuf:"varint,2,opt,name=host_id,json=hostId,proto3" json:"host_id,omitempty"`
	Page                 uint32   `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	Limit                uint32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	CreatedAtMin         string   `protobuf:"bytes,5,opt,name=created_at_min,json=createdAtMin,proto3" json:"created_at_min,omitempty"`
	CreatedAtMax         string   `protobuf:"bytes,6,opt,name=created_at_max,json=createdAtMax,proto3" json:"created_at_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListHostBookingRequest) Reset()         { *m = ListHostBookingRequest{} }
func (m *ListHostBookingRequest) String() string { return proto.CompactTextString(m) }
func (*ListHostBookingRequest) ProtoMessage()    {}
func (*ListHostBookingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{5}
}
func (m *ListHostBookingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHostBookingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHostBookingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHostBookingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHostBookingRequest.Merge(m, src)
}
func (m *ListHostBookingRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListHostBookingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHostBookingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHostBookingRequest proto.InternalMessageInfo

func (m *ListHostBookingRequest) GetHostId() uint32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *ListHostBookingRequest) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListHostBookingRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListHostBookingRequest) GetCreatedAtMin() string {
	if m != nil {
		return m.CreatedAtMin
	}
	return ""
}

func (m *ListHostBookingRequest) GetCreatedAtMax() string {
	if m != nil {
		return m.CreatedAtMax
	}
	return ""
}

func (*ListHostBookingRequest) XXX_MessageName() string {
	return "booking.ListHostBookingRequest"
}

type ListHostBookingResponse struct {
	Items                []*Booking `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	MaxPage              uint32     `protobuf:"varint,2,opt,name=max_page,json=maxPage,proto3" json:"max_page,omitempty"`
	TotalCount           uint32     `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	Page                 uint32     `protobuf:"varint,4,opt,name=page,proto3" json:"page,omitempty"`
	Limit                uint32     `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListHostBookingResponse) Reset()         { *m = ListHostBookingResponse{} }
func (m *ListHostBookingResponse) String() string { return proto.CompactTextString(m) }
func (*ListHostBookingResponse) ProtoMessage()    {}
func (*ListHostBookingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ffdf80b5823d65, []int{6}
}
func (m *ListHostBookingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHostBookingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHostBookingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHostBookingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHostBookingResponse.Merge(m, src)
}
func (m *ListHostBookingResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListHostBookingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHostBookingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListHostBookingResponse proto.InternalMessageInfo

func (m *ListHostBookingResponse) GetItems() []*Booking {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListHostBookingResponse) GetMaxPage() uint32 {
	if m != nil {
		return m.MaxPage
	}
	return 0
}

func (m *ListHostBookingResponse) GetTotalCount() uint32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ListHostBookingResponse) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListHostBookingResponse) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (*ListHostBookingResponse) XXX_MessageName() string {
	return "booking.ListHostBookingResponse"
}
func init() {
	proto.RegisterType((*Booking)(nil), "booking.Booking")
	golang_proto.RegisterType((*Booking)(nil), "booking.Booking")
	proto.RegisterType((*BookingV2)(nil), "booking.BookingV2")
	golang_proto.RegisterType((*BookingV2)(nil), "booking.BookingV2")
	proto.RegisterType((*OneBookingRequest)(nil), "booking.OneBookingRequest")
	golang_proto.RegisterType((*OneBookingRequest)(nil), "booking.OneBookingRequest")
	proto.RegisterType((*ListCustomerBookingRequest)(nil), "booking.ListCustomerBookingRequest")
	golang_proto.RegisterType((*ListCustomerBookingRequest)(nil), "booking.ListCustomerBookingRequest")
	proto.RegisterType((*ListCustomerBookingResponse)(nil), "booking.ListCustomerBookingResponse")
	golang_proto.RegisterType((*ListCustomerBookingResponse)(nil), "booking.ListCustomerBookingResponse")
	proto.RegisterType((*ListHostBookingRequest)(nil), "booking.ListHostBookingRequest")
	golang_proto.RegisterType((*ListHostBookingRequest)(nil), "booking.ListHostBookingRequest")
	proto.RegisterType((*ListHostBookingResponse)(nil), "booking.ListHostBookingResponse")
	golang_proto.RegisterType((*ListHostBookingResponse)(nil), "booking.ListHostBookingResponse")
}

func init() { proto.RegisterFile("booking/booking.proto", fileDescriptor_00ffdf80b5823d65) }
func init() { golang_proto.RegisterFile("booking/booking.proto", fileDescriptor_00ffdf80b5823d65) }

var fileDescriptor_00ffdf80b5823d65 = []byte{
	// 896 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x97, 0xb3, 0x9b, 0xa4, 0x79, 0xbb, 0x1b, 0xb6, 0xa3, 0xdd, 0xd4, 0xb8, 0x25, 0x8d, 0xdc,
	0xaa, 0x8a, 0x10, 0x1b, 0x4b, 0x41, 0x42, 0x82, 0x5b, 0x37, 0x48, 0x14, 0x89, 0xb2, 0x5b, 0x57,
	0xda, 0x03, 0x07, 0xac, 0x89, 0x3d, 0xf1, 0x0e, 0x1b, 0xcf, 0x18, 0x7b, 0x82, 0xd2, 0x22, 0x38,
	0xf4, 0xc6, 0x19, 0x89, 0xaf, 0xd0, 0x03, 0x47, 0xbe, 0x00, 0xc7, 0x1e, 0x91, 0xf8, 0x02, 0x68,
	0xcb, 0x07, 0x41, 0x7e, 0x33, 0xce, 0x3a, 0xc9, 0xb6, 0x62, 0x7b, 0x81, 0x5e, 0xe2, 0x79, 0xff,
	0x7e, 0x6f, 0x7e, 0xbf, 0xe7, 0x99, 0x18, 0xf6, 0xc7, 0x52, 0x9e, 0x71, 0x11, 0x7b, 0xe6, 0x39,
	0x48, 0x33, 0xa9, 0x24, 0x69, 0x1a, 0xd3, 0x39, 0x88, 0xb9, 0x3a, 0x9d, 0x8d, 0x07, 0xa1, 0x4c,
	0xbc, 0x58, 0xc6, 0xd2, 0xc3, 0xf8, 0x78, 0x36, 0x41, 0x0b, 0x0d, 0x5c, 0xe9, 0x3a, 0xe7, 0x56,
	0x2c, 0x65, 0x3c, 0x65, 0x1e, 0x4d, 0xb9, 0x47, 0x85, 0x90, 0x8a, 0x2a, 0x2e, 0x45, 0x6e, 0xa2,
	0x9f, 0x55, 0xc0, 0x04, 0x3b, 0xe3, 0x4f, 0x9f, 0x7a, 0x13, 0x2e, 0xe8, 0xf4, 0x20, 0xcd, 0xe4,
	0x37, 0x2c, 0x54, 0xde, 0x98, 0x86, 0x67, 0x4c, 0x44, 0x5e, 0x2c, 0x0f, 0xd2, 0xb1, 0x7a, 0x92,
	0x32, 0x2f, 0xa5, 0x4f, 0x12, 0x26, 0x54, 0xf9, 0x34, 0x40, 0x0f, 0xaf, 0x0e, 0x54, 0x10, 0x62,
	0x51, 0x26, 0x65, 0x52, 0x59, 0x1a, 0xb8, 0xd1, 0xd5, 0xe1, 0x4e, 0xa5, 0x62, 0x53, 0xfd, 0x6b,
	0x40, 0x1e, 0x5d, 0x1d, 0x44, 0x48, 0xc5, 0x27, 0x3c, 0x44, 0x8d, 0x96, 0x0c, 0x0d, 0xe9, 0xfe,
	0xb4, 0x01, 0xcd, 0x43, 0x3d, 0x08, 0xd2, 0x86, 0x1a, 0x8f, 0x6c, 0xab, 0x67, 0xf5, 0xeb, 0x7e,
	0x8d, 0x47, 0x84, 0xc0, 0xa6, 0x90, 0x8a, 0xd9, 0x9b, 0x3d, 0xab, 0xdf, 0xf2, 0x71, 0x4d, 0x6e,
	0xc3, 0x96, 0x92, 0x8a, 0x4e, 0x83, 0x34, 0xe3, 0x21, 0xb3, 0xeb, 0x3d, 0xab, 0x5f, 0xf3, 0x01,
	0x5d, 0xc7, 0x85, 0x87, 0x74, 0xa0, 0x91, 0x2b, 0xaa, 0x66, 0xb9, 0xdd, 0xc0, 0x32, 0x63, 0x15,
	0x85, 0xe1, 0x2c, 0x57, 0x32, 0x61, 0x59, 0xc0, 0x23, 0xfb, 0x1a, 0x76, 0x81, 0xd2, 0xf5, 0x79,
	0x44, 0x5c, 0xa8, 0x23, 0x57, 0xbb, 0xd9, 0xb3, 0xfa, 0x5b, 0xc3, 0xed, 0x81, 0x66, 0xfe, 0xa0,
	0xf8, 0xf5, 0x75, 0x88, 0x7c, 0x00, 0x4d, 0x33, 0x25, 0xbb, 0x85, 0x59, 0x64, 0x50, 0x4e, 0xed,
	0x58, 0x3f, 0x4f, 0x86, 0x7e, 0x99, 0x42, 0xde, 0x03, 0xc8, 0x15, 0xcd, 0x54, 0x10, 0x51, 0xc5,
	0x6c, 0xc0, 0xed, 0xb4, 0xd0, 0xf3, 0x29, 0x55, 0x8c, 0xbc, 0x0b, 0xd7, 0x98, 0x88, 0x74, 0x70,
	0x0b, 0x83, 0x4d, 0x26, 0x22, 0x0c, 0x7d, 0x04, 0x70, 0x31, 0x41, 0x7b, 0xbb, 0xb7, 0xd1, 0xdf,
	0x1a, 0x76, 0x06, 0x95, 0xa1, 0x1e, 0xe2, 0xd2, 0x97, 0x32, 0xf1, 0x2b, 0x99, 0x45, 0xc7, 0x30,
	0x63, 0x54, 0xb1, 0x28, 0xa0, 0xca, 0xde, 0xd3, 0x1d, 0x8d, 0xe7, 0x3e, 0x6e, 0x68, 0x96, 0x46,
	0x65, 0x78, 0x5f, 0x87, 0x8d, 0xe7, 0xbe, 0x72, 0x7f, 0xa9, 0x41, 0xcb, 0xcc, 0xe2, 0x64, 0xf8,
	0x6f, 0xa7, 0xf1, 0x7a, 0x51, 0xf7, 0xa0, 0x8e, 0xb3, 0x41, 0xb9, 0x6a, 0xbe, 0x36, 0xde, 0x3a,
	0x61, 0xee, 0xc0, 0xf5, 0x23, 0xc1, 0x8c, 0x34, 0x3e, 0xfb, 0x76, 0xc6, 0x72, 0x55, 0xd1, 0x67,
	0xa7, 0xd0, 0xc7, 0xfd, 0xcd, 0x02, 0xe7, 0x0b, 0x9e, 0xab, 0x91, 0x61, 0xbf, 0x92, 0xbe, 0x22,
	0x55, 0x0d, 0xeb, 0xaa, 0x52, 0x11, 0xd8, 0x4c, 0x69, 0xcc, 0xec, 0x0d, 0x8c, 0xe0, 0xba, 0x90,
	0x6f, 0xca, 0x13, 0xae, 0x50, 0xf4, 0x1d, 0x5f, 0x1b, 0xe4, 0x2e, 0xb4, 0x2f, 0xc8, 0x04, 0x09,
	0x17, 0x78, 0x0c, 0x5a, 0xfe, 0xf6, 0x82, 0xd0, 0x43, 0x2e, 0x56, 0xb3, 0xe8, 0xdc, 0x1c, 0x88,
	0x4a, 0x16, 0x9d, 0xbb, 0xbf, 0x5a, 0x70, 0xf3, 0xd2, 0x5d, 0xe7, 0xa9, 0x14, 0x39, 0x23, 0xf7,
	0xa0, 0xce, 0x15, 0x4b, 0x72, 0xdb, 0x42, 0xad, 0x77, 0x07, 0xe5, 0x25, 0x5a, 0x26, 0xea, 0x70,
	0x31, 0xb3, 0x84, 0xce, 0x03, 0x64, 0xa0, 0xb9, 0x35, 0x13, 0x3a, 0x3f, 0x2e, 0x48, 0x2c, 0x8e,
	0x6c, 0x28, 0x67, 0x42, 0x19, 0x7e, 0xfa, 0xc8, 0x8e, 0x0a, 0xcf, 0x82, 0xf9, 0xe6, 0x65, 0xcc,
	0xeb, 0x15, 0xe6, 0xee, 0x73, 0x0b, 0x3a, 0xc5, 0x6e, 0x1f, 0xc8, 0x5c, 0xad, 0xe8, 0x7b, 0x03,
	0x9a, 0xa7, 0x32, 0x57, 0x17, 0xda, 0x36, 0x0a, 0xf3, 0x3f, 0xd3, 0xf5, 0xb9, 0x05, 0x37, 0xd6,
	0x76, 0xfa, 0x7f, 0xd4, 0x74, 0xf8, 0xac, 0x0e, 0x6d, 0xd3, 0xf8, 0x31, 0xcb, 0xbe, 0x2b, 0xee,
	0xd0, 0x47, 0xd0, 0x1e, 0x49, 0x31, 0xe1, 0x59, 0x52, 0x5e, 0xcd, 0x6b, 0x7b, 0x74, 0xd6, 0x3c,
	0xee, 0xcd, 0x67, 0x7f, 0xfe, 0xfd, 0x73, 0x6d, 0xdf, 0xdd, 0xf5, 0x42, 0x5d, 0x1c, 0x98, 0x8c,
	0x4f, 0xac, 0xf7, 0xc9, 0x63, 0xd8, 0x19, 0xa1, 0x3e, 0x25, 0x22, 0x59, 0xad, 0x3f, 0x19, 0x3a,
	0x97, 0xf8, 0x5c, 0x07, 0x51, 0xf7, 0xdc, 0x77, 0x3c, 0xad, 0x6f, 0x15, 0xf4, 0x47, 0xd8, 0x2f,
	0x34, 0x36, 0xc9, 0x47, 0x93, 0xf2, 0x25, 0x26, 0x77, 0x16, 0x40, 0xaf, 0x3e, 0x91, 0xce, 0xdd,
	0xd7, 0x27, 0xe9, 0x61, 0x95, 0xfd, 0x09, 0xf1, 0x16, 0xc7, 0xd7, 0x94, 0xe5, 0x44, 0xc0, 0xf5,
	0xa5, 0xfe, 0xc5, 0xb0, 0xc9, 0xed, 0x25, 0xd8, 0xf5, 0x37, 0xd5, 0xe9, 0xbd, 0x3a, 0xc1, 0xf4,
	0xec, 0x60, 0xcf, 0x5d, 0xd2, 0xf6, 0xf0, 0x95, 0x5e, 0xf4, 0xfb, 0x1a, 0x1a, 0x23, 0x2a, 0x42,
	0x36, 0x25, 0xce, 0x02, 0x63, 0xed, 0x62, 0x72, 0x9c, 0xc1, 0xd2, 0xff, 0xec, 0x97, 0x15, 0xc3,
	0xbd, 0x85, 0xc8, 0x1d, 0x77, 0xcf, 0x0b, 0x11, 0xa8, 0xc4, 0xf6, 0xbe, 0xe7, 0xd1, 0x0f, 0x64,
	0x0e, 0x9d, 0xd1, 0x29, 0x15, 0x31, 0x1b, 0xc9, 0x24, 0x9d, 0x32, 0xc5, 0xa2, 0x72, 0x5a, 0x6f,
	0xda, 0xef, 0x1e, 0xf6, 0xeb, 0xb9, 0x5d, 0x2f, 0x44, 0xe0, 0x20, 0x2c, 0x91, 0x97, 0x3a, 0x1f,
	0x1e, 0xbd, 0x38, 0xef, 0x5a, 0x7f, 0x9c, 0x77, 0xad, 0xbf, 0xce, 0xbb, 0xd6, 0xef, 0x2f, 0xbb,
	0xd6, 0x8b, 0x97, 0x5d, 0xeb, 0xab, 0x8f, 0xdf, 0xec, 0x1b, 0x88, 0x8b, 0x78, 0xdc, 0xc0, 0xcf,
	0x8b, 0x0f, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x0a, 0x8b, 0x18, 0xfc, 0xfd, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BookingServiceClient is the client API for BookingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BookingServiceClient interface {
	ConfirmBooking(ctx context.Context, in *Booking, opts ...grpc.CallOption) (*Booking, error)
	CreateBooking(ctx context.Context, in *BookingV2, opts ...grpc.CallOption) (*BookingV2, error)
	ListBookingOfCustomer(ctx context.Context, in *ListCustomerBookingRequest, opts ...grpc.CallOption) (*ListCustomerBookingResponse, error)
	ListBookingOfHost(ctx context.Context, in *ListHostBookingRequest, opts ...grpc.CallOption) (*ListHostBookingResponse, error)
	Cancel(ctx context.Context, in *OneBookingRequest, opts ...grpc.CallOption) (*notification.Notification, error)
	ChangeCompletedBooking(ctx context.Context, in *OneBookingRequest, opts ...grpc.CallOption) (*notification.Notification, error)
}

type bookingServiceClient struct {
	cc *grpc.ClientConn
}

func NewBookingServiceClient(cc *grpc.ClientConn) BookingServiceClient {
	return &bookingServiceClient{cc}
}

func (c *bookingServiceClient) ConfirmBooking(ctx context.Context, in *Booking, opts ...grpc.CallOption) (*Booking, error) {
	out := new(Booking)
	err := c.cc.Invoke(ctx, "/booking.BookingService/ConfirmBooking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) CreateBooking(ctx context.Context, in *BookingV2, opts ...grpc.CallOption) (*BookingV2, error) {
	out := new(BookingV2)
	err := c.cc.Invoke(ctx, "/booking.BookingService/CreateBooking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) ListBookingOfCustomer(ctx context.Context, in *ListCustomerBookingRequest, opts ...grpc.CallOption) (*ListCustomerBookingResponse, error) {
	out := new(ListCustomerBookingResponse)
	err := c.cc.Invoke(ctx, "/booking.BookingService/ListBookingOfCustomer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) ListBookingOfHost(ctx context.Context, in *ListHostBookingRequest, opts ...grpc.CallOption) (*ListHostBookingResponse, error) {
	out := new(ListHostBookingResponse)
	err := c.cc.Invoke(ctx, "/booking.BookingService/ListBookingOfHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) Cancel(ctx context.Context, in *OneBookingRequest, opts ...grpc.CallOption) (*notification.Notification, error) {
	out := new(notification.Notification)
	err := c.cc.Invoke(ctx, "/booking.BookingService/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) ChangeCompletedBooking(ctx context.Context, in *OneBookingRequest, opts ...grpc.CallOption) (*notification.Notification, error) {
	out := new(notification.Notification)
	err := c.cc.Invoke(ctx, "/booking.BookingService/ChangeCompletedBooking", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BookingServiceServer is the server API for BookingService service.
type BookingServiceServer interface {
	ConfirmBooking(context.Context, *Booking) (*Booking, error)
	CreateBooking(context.Context, *BookingV2) (*BookingV2, error)
	ListBookingOfCustomer(context.Context, *ListCustomerBookingRequest) (*ListCustomerBookingResponse, error)
	ListBookingOfHost(context.Context, *ListHostBookingRequest) (*ListHostBookingResponse, error)
	Cancel(context.Context, *OneBookingRequest) (*notification.Notification, error)
	ChangeCompletedBooking(context.Context, *OneBookingRequest) (*notification.Notification, error)
}

// UnimplementedBookingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBookingServiceServer struct {
}

func (*UnimplementedBookingServiceServer) ConfirmBooking(ctx context.Context, req *Booking) (*Booking, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmBooking not implemented")
}
func (*UnimplementedBookingServiceServer) CreateBooking(ctx context.Context, req *BookingV2) (*BookingV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBooking not implemented")
}
func (*UnimplementedBookingServiceServer) ListBookingOfCustomer(ctx context.Context, req *ListCustomerBookingRequest) (*ListCustomerBookingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBookingOfCustomer not implemented")
}
func (*UnimplementedBookingServiceServer) ListBookingOfHost(ctx context.Context, req *ListHostBookingRequest) (*ListHostBookingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBookingOfHost not implemented")
}
func (*UnimplementedBookingServiceServer) Cancel(ctx context.Context, req *OneBookingRequest) (*notification.Notification, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (*UnimplementedBookingServiceServer) ChangeCompletedBooking(ctx context.Context, req *OneBookingRequest) (*notification.Notification, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeCompletedBooking not implemented")
}

func RegisterBookingServiceServer(s *grpc.Server, srv BookingServiceServer) {
	s.RegisterService(&_BookingService_serviceDesc, srv)
}

func _BookingService_ConfirmBooking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Booking)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).ConfirmBooking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/ConfirmBooking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).ConfirmBooking(ctx, req.(*Booking))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_CreateBooking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BookingV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).CreateBooking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/CreateBooking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).CreateBooking(ctx, req.(*BookingV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_ListBookingOfCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCustomerBookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).ListBookingOfCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/ListBookingOfCustomer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).ListBookingOfCustomer(ctx, req.(*ListCustomerBookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_ListBookingOfHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostBookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).ListBookingOfHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/ListBookingOfHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).ListBookingOfHost(ctx, req.(*ListHostBookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OneBookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).Cancel(ctx, req.(*OneBookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_ChangeCompletedBooking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OneBookingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).ChangeCompletedBooking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/ChangeCompletedBooking",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).ChangeCompletedBooking(ctx, req.(*OneBookingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BookingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "booking.BookingService",
	HandlerType: (*BookingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfirmBooking",
			Handler:    _BookingService_ConfirmBooking_Handler,
		},
		{
			MethodName: "CreateBooking",
			Handler:    _BookingService_CreateBooking_Handler,
		},
		{
			MethodName: "ListBookingOfCustomer",
			Handler:    _BookingService_ListBookingOfCustomer_Handler,
		},
		{
			MethodName: "ListBookingOfHost",
			Handler:    _BookingService_ListBookingOfHost_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _BookingService_Cancel_Handler,
		},
		{
			MethodName: "ChangeCompletedBooking",
			Handler:    _BookingService_ChangeCompletedBooking_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "booking/booking.proto",
}

func (m *Booking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Booking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Booking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Bookedroom) > 0 {
		for iNdEx := len(m.Bookedroom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bookedroom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.EndDate) > 0 {
		i -= len(m.EndDate)
		copy(dAtA[i:], m.EndDate)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.EndDate)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.StartDate) > 0 {
		i -= len(m.StartDate)
		copy(dAtA[i:], m.StartDate)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.StartDate)))
		i--
		dAtA[i] = 0x52
	}
	if m.Payment != nil {
		{
			size, err := m.Payment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBooking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CustomerId != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.CustomerId))
		i--
		dAtA[i] = 0x40
	}
	if m.Hotel != nil {
		{
			size, err := m.Hotel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBooking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if m.TotalPrice != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalPrice))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BookingV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BookingV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BookingV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Bookedroom) > 0 {
		for iNdEx := len(m.Bookedroom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bookedroom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.EndDate) > 0 {
		i -= len(m.EndDate)
		copy(dAtA[i:], m.EndDate)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.EndDate)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.StartDate) > 0 {
		i -= len(m.StartDate)
		copy(dAtA[i:], m.StartDate)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.StartDate)))
		i--
		dAtA[i] = 0x52
	}
	if m.Total != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Total))))
		i--
		dAtA[i] = 0x4d
	}
	if m.CustomerId != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.CustomerId))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OneBookingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneBookingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OneBookingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListCustomerBookingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCustomerBookingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCustomerBookingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CreatedAtMax) > 0 {
		i -= len(m.CreatedAtMax)
		copy(dAtA[i:], m.CreatedAtMax)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAtMax)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAtMin) > 0 {
		i -= len(m.CreatedAtMin)
		copy(dAtA[i:], m.CreatedAtMin)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAtMin)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Page != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if m.CustomerId != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.CustomerId))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ListCustomerBookingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCustomerBookingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCustomerBookingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Page != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalCount != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPage != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.MaxPage))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListHostBookingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHostBookingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHostBookingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CreatedAtMax) > 0 {
		i -= len(m.CreatedAtMax)
		copy(dAtA[i:], m.CreatedAtMax)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAtMax)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreatedAtMin) > 0 {
		i -= len(m.CreatedAtMin)
		copy(dAtA[i:], m.CreatedAtMin)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAtMin)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Page != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if m.HostId != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.HostId))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ListHostBookingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHostBookingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHostBookingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Page != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalCount != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPage != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.MaxPage))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBooking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBooking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Booking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBooking(uint64(m.Id))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.TotalPrice != 0 {
		n += 5
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.Hotel != nil {
		l = m.Hotel.Size()
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.CustomerId != 0 {
		n += 1 + sovBooking(uint64(m.CustomerId))
	}
	if m.Payment != nil {
		l = m.Payment.Size()
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.StartDate)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if len(m.Bookedroom) > 0 {
		for _, e := range m.Bookedroom {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 2 + l + sovBooking(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 2 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BookingV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBooking(uint64(m.Id))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.CustomerId != 0 {
		n += 1 + sovBooking(uint64(m.CustomerId))
	}
	if m.Total != 0 {
		n += 5
	}
	l = len(m.StartDate)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if len(m.Bookedroom) > 0 {
		for _, e := range m.Bookedroom {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 2 + l + sovBooking(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 2 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OneBookingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBooking(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCustomerBookingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomerId != 0 {
		n += 1 + sovBooking(uint64(m.CustomerId))
	}
	if m.Page != 0 {
		n += 1 + sovBooking(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	l = len(m.CreatedAtMin)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.CreatedAtMax)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCustomerBookingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.MaxPage != 0 {
		n += 1 + sovBooking(uint64(m.MaxPage))
	}
	if m.TotalCount != 0 {
		n += 1 + sovBooking(uint64(m.TotalCount))
	}
	if m.Page != 0 {
		n += 1 + sovBooking(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHostBookingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostId != 0 {
		n += 1 + sovBooking(uint64(m.HostId))
	}
	if m.Page != 0 {
		n += 1 + sovBooking(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	l = len(m.CreatedAtMin)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.CreatedAtMax)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHostBookingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.MaxPage != 0 {
		n += 1 + sovBooking(uint64(m.MaxPage))
	}
	if m.TotalCount != 0 {
		n += 1 + sovBooking(uint64(m.TotalCount))
	}
	if m.Page != 0 {
		n += 1 + sovBooking(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBooking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBooking(x uint64) (n int) {
	return sovBooking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Booking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Booking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Booking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrice", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalPrice = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hotel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hotel == nil {
				m.Hotel = &hotel.Hotel{}
			}
			if err := m.Hotel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			m.CustomerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payment == nil {
				m.Payment = &payment.PaymentV2{}
			}
			if err := m.Payment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bookedroom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bookedroom = append(m.Bookedroom, &bookedroom.BookedRoom{})
			if err := m.Bookedroom[len(m.Bookedroom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BookingV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BookingV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BookingV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			m.CustomerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Total = float32(math.Float32frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bookedroom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bookedroom = append(m.Bookedroom, &bookedroom.BookedRoom{})
			if err := m.Bookedroom[len(m.Bookedroom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneBookingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneBookingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneBookingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCustomerBookingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCustomerBookingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCustomerBookingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			m.CustomerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAtMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAtMax = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCustomerBookingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCustomerBookingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCustomerBookingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Booking{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPage", wireType)
			}
			m.MaxPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHostBookingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHostBookingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHostBookingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAtMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAtMax = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHostBookingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHostBookingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHostBookingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Booking{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPage", wireType)
			}
			m.MaxPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBooking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBooking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBooking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBooking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBooking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBooking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBooking = fmt.Errorf("proto: unexpected end of group")
)
